#!/usr/bin/env perl6

# header {{{1
v6;
use fatal;
use Data::Dump;
#}}}

sub naturally ($a) {
  $a.lc.subst(/(\d+)/, -> $/ { 0 ~ $0.chars.chr ~ $0 }, :g) ~ "\x0" ~ $a
}

sub MAIN () {
  CONTROL {
    when CX::Warn {
      note $_;
      exit 1;
    }
  }

  my %coord;
  my %blank;

  for qq:x{ls *.sprite.png | sort -V}.lines -> $png {
    my $name = $png.split('.')[0];

    my $buf = qq:x{identify $png}.split(' ')[3];
    my (Any, $x, $y) = $buf.split('+');
    %coord{$name} = {x => $x, y => $y};

    my (Any, $progmem, $data) = "$name.h".IO.slurp.split("\n\n");

    if $data ~~ /0x <[1 .. 9A .. F]> ** 4/ {
      say $data;
      say '';
    }
    else {
      %blank{$name}++;
    }
  }

  #print q:to/END/;
  #extern ustd::map<uint8_t, const uint16_t(*)[64]> sprite;
  #extern ustd::map<uint8_t, bool> is_blank;
  #struct Point { uint8_t x, y; };
  #extern const struct Point sprite_coord[256];
  #END

  my $initf = open "dial_face_sprites_init.h", :w;
  #$initf.print: q:to/END/;
  #ustd::map<uint8_t, const uint16_t(*)[64]> sprite;
  #ustd::map<uint8_t, bool> is_blank;
  #const struct Point sprite_coord[256] = {
  #END
  for %coord.keys.sort: { .&naturally } -> $name {
    my (Any, Any, $index) = $name.split: '_';
    $initf.print: qq:to/END/;
      \{x: %coord{$name}<x>, y: %coord{$name}<y>\}{$index == 255 ?? '' !! ','}
    END
  }
  $initf.print: q:to/END/;
  };
  END

  for %coord.keys.sort: { .&naturally } -> $name {
    unless %blank{$name} {
      my (Any, Any, $index) = $name.split: '_';
      $initf.print: qq:to/END/;
      sprite[$index] = &{$name};
      END
    }
  }


  $initf.close;
}
