#include <RS485_protocol.h>
#include "LibPrintf.h"


const byte TX_ENABLE_PIN = 4;

// Callbacks
void ftdiWrite (const byte what) {
  Serial.write (what);
}

int ftdiAvailable () {
  return Serial.available ();
}

int ftdiRead () {
  return Serial.read ();
}


void rs485Write (const byte what) {
  Serial1.write (what);
}

int rs485Available () {
  return Serial1.available ();
}

int rs485Read () {
  return Serial1.read ();
}



// the setup function runs once when you press reset or power the board
void setup() {
  Serial.begin(9600);
  Serial1.begin(38400, SERIAL_8N1);  // SERIAL_8N1 is the default

  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);

  // DE / RE Controling pin of RS-485
  pinMode(TX_ENABLE_PIN, OUTPUT);
}


// Send a Fujikin message of "length" bytes (max 255) to other end
void sendFujikinMessage (WriteCallback fSend, const byte * data, const byte length) {
  for (byte i = 0; i < length; i++) {
    fSend(data [i]);
  }
}


void loop() {
  digitalWrite(LED_BUILTIN, HIGH); // LED off
  delay(5);
  digitalWrite(LED_BUILTIN, LOW); // LED off

  // assemble message for product name retrieval
  byte msg [] = {
     0x21,    // Default Fujikin MAC ID
     0x02,    // STX
     0x80,    // Read command code
     0x03,    // Packet length
     0x01,    // Class ID
     0x01,    // Instance ID
     0x07,    // Attribute ID
     0x00,    // Padding (no data)
     0x8e     // Checksum
  };

  // send to Fujikin
  digitalWrite (TX_ENABLE_PIN, HIGH);    // enable sending
  sendFujikinMessage (rs485Write, msg, sizeof msg);
  delayMicroseconds(2250);
  digitalWrite (TX_ENABLE_PIN, LOW);     // disable sending

  // // receive response
  // byte buf [10] = {0};
  // byte received = recvMsg (rs485Available, rs485Read, buf, sizeof buf);
  // printf ("received %d\n", received);
  // digitalWrite (LED_BUILTIN, received == 0);  // turn on LED if error

  // printf ("buf %d, %d\n", buf[0], buf[1]);

  delay(50);
}
